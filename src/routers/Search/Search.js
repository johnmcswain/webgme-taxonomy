/*globals define*/

/**
 * Generated by RestRouterGenerator 2.2.0 from webgme on Wed Aug 03 2022 22:46:01 GMT-0500 (Central Daylight Time).
 * To use in webgme add to gmeConfig.rest.components[Search] = {
 *    mount: 'path/subPath',
 *    src: path.join(process.cwd(), './Search'),
 *    options: {}
 * }
 * If you put this file in the root of your directory the above will expose the routes at
 * <host>/path/subPath, for example GET <host>/path/subPath/getExample will be routed to the getExample below.
 */

"use strict";

// http://expressjs.com/en/guide/routing.html
var express = require("express"),
  router = express.Router(),
  logger;

const _ = require("underscore");
const fetch = require("node-fetch");
const RouterUtils = require("../../common/routers/Utils");
const Utils = require("../../common/Utils");
const SearchFilterDataExporter = require("../../common/SearchFilterDataExporter");
const path = require("path");
const staticPath = path.join(__dirname, "dashboard", "public");

const agent = require("superagent");
let mainConfig = null;
const pdpBase = "https://leappremonitiondev.azurewebsites.net/";
const getAccessToken = (req) => {
  //return require('./token');
  return req.cookies[mainConfig.authentication.azureActiveDirectory.cookieId];
};

const getProcessObservations = async (pid, token) => {
  const opts = {
    headers: {
      Authorization: "Bearer " + token,
    },
  };
  const response = await fetch(
    pdpBase + `v2/Process/GetProcessState?processId=${pid}`,
    opts
  );

  const obsInfo = await response.json();
  const results = [];
  for (let i = 1; i < obsInfo.numObservations; i += 1) {
    results.push(
      await agent
        .get(
          pdpBase +
            "v2/Process/GetObservation?processId=" +
            pid +
            "&obsIndex=" +
            i
        )
        .set("Authorization", "Bearer " + token)
    );
  }
  const observations = results.map((result) => result.body);

  return observations;
};

const listArtifacts = async (type, token) => {
  try {
    let response = await agent
      .get(pdpBase + "v2/Process/ListProcesses")
      .query({ permission: "read" })
      .set("Authorization", "Bearer " + token);
    if (response.ok !== true) {
      throw new Error(
        "Initial list fetching failed [" + response.statusCode + "]"
      );
    }

    const processList = response.body.filter(
      (element) => element.processType === type
    );

    const processObservations = await Promise.all(
      processList.map(
        async (process) =>
          await getProcessObservations(process.processId, token)
      )
    );

    return processObservations.flat();
  } catch (e) {
    logger.error(e);
    return [];
  }
};

const getDownloadUrls = async (processId, obsIndex, version, token) => {
  const queryDict = _.mapObject(
    {
      processId,
      obsIndex,
      version,
      endObsIndex: obsIndex + 1,
    },
    encodeURIComponent
  );
  const queryString = Object.entries(queryDict)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");
  const url = pdpBase + `v3/Files/GetObservationFiles?${queryString}`;
  const opts = {
    headers: {
      Authorization: "Bearer " + token,
    },
  };
  const response = await fetch(url, opts);
  console.log(response.status);
  const result = await response.json();
  return result.files.map((file) => file.sasUrl);
};

/* N.B. gmeAuth, safeStorage and workerManager are not ready to use until the start function is called.
 * (However inside an incoming request they are all ensured to have been initialized.)
 *
 * @param {object} middlewareOpts - Passed by the webgme server.
 * @param {GmeConfig} middlewareOpts.gmeConfig - GME config parameters.
 * @param {GmeLogger} middlewareOpts.logger - logger
 * @param {function} middlewareOpts.ensureAuthenticated - Ensures the user is authenticated.
 * @param {function} middlewareOpts.getUserId - If authenticated retrieves the userId from the request.
 * @param {object} middlewareOpts.gmeAuth - Authorization module.
 * @param {object} middlewareOpts.safeStorage - Accesses the storage and emits events (PROJECT_CREATED, COMMIT..).
 * @param {object} middlewareOpts.workerManager - Spawns and keeps track of "worker" sub-processes.
 */
function initialize(middlewareOpts) {
  const ensureAuthenticated = middlewareOpts.ensureAuthenticated;

  logger = middlewareOpts.logger.fork("Search");
  logger.debug("initializing ...");

  mainConfig = middlewareOpts.gmeConfig;

  // Ensure authenticated can be used only after this rule.
  router.use("*", function (req, res, next) {
    // TODO: set all headers, check rate limit, etc.

    // This header ensures that any failures with authentication won't redirect.
    res.setHeader("X-WebGME-Media-Type", "webgme.v1");
    next();
  });

  // Use ensureAuthenticated if the routes require authentication. (Can be set explicitly for each route.)
  router.use("*", ensureAuthenticated);

  router.use("/:projectId/branch/:branch/static/", express.static(staticPath));

  // Perhaps the path should include the node ID, too...
  router.use("/:projectId/branch/:branch/", async (req, res, next) => {
    try {
      const { projectId, branch } = req.params;
      req.webgmeContext = await RouterUtils.getWebGMEContext(
        middlewareOpts,
        req,
        projectId,
        branch
      );
      next();
    } catch (e) {
      logger.error(e);
      res.sendStatus(500);
    }
  });

  router.get(
    "/:projectId/branch/:branch/taxonomy.json",
    async function (req, res) {
      const { root, core } = req.webgmeContext;
      const exporter = new SearchFilterDataExporter(core);
      const node = await Utils.findTaxonomyNode(core, root);
      const data = await exporter.toSchema(node);
      res.json(data);
    }
  );

  // Accessing and updating data via the storage adapter
  router.get(
    "/:projectId/branch/:branch/artifacts/",
    // TODO: add the artifact ID...
    async function (req, res) {
      try {
        // TODO: make the collection/db part of the config
        const artifacts = await listArtifacts("testdata", getAccessToken(req));
        artifacts.forEach(
          (artifact) =>
            (artifact.id = [
              artifact.processId,
              artifact.index,
              artifact.index,
            ].join("_"))
        );
        res.status(200).json(artifacts).end();
      } catch (e) {
        logger.error(e);
        res.sendStatus(401);
      }
    }
  );

  router.post(
    "/:projectId/branch/:branch/artifacts/",
    async function (req, res) {
      // TODO: create new artifact
      res.json(data);
    }
  );

  router.patch(
    "/:projectId/branch/:branch/artifacts/:id",
    async function (req, res) {
      // TODO: update artifact
      res.json(data);
    }
  );

  router.get(
    "/:projectId/branch/:branch/artifacts/:id/downloadUrl",
    async function (req, res) {
      const { id } = req.params;
      console.log("getting download URL", id);
      const [processId, obsIndex, version] = id.split("_");

      const urls = await getDownloadUrls(
        processId,
        obsIndex,
        version,
        getAccessToken(req)
      );
      return res.json(urls);
    }
  );

  logger.debug("ready");
}

/**
 * Called before the server starts listening.
 * @param {function} callback
 */
function start(callback) {
  callback();
}

/**
 * Called after the server stopped listening.
 * @param {function} callback
 */
function stop(callback) {
  callback();
}

module.exports = {
  initialize: initialize,
  router: router,
  start: start,
  stop: stop,
};
